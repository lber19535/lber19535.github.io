<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lber19535.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="阅读 《C++Primer 第五版》第四章 表达式 所做的一些笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记之三">
<meta property="og:url" content="https://lber19535.github.io/2015/08/03/2015/2015-08-03-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/index.html">
<meta property="og:site_name" content="LOST HOME">
<meta property="og:description" content="阅读 《C++Primer 第五版》第四章 表达式 所做的一些笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2015-08-03T17:00:00.000Z">
<meta property="article:modified_time" content="2022-08-30T09:51:54.416Z">
<meta property="article:author" content="Bill Lv">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lber19535.github.io/2015/08/03/2015/2015-08-03-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lber19535.github.io/2015/08/03/2015/2015-08-03-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/","path":"2015/08/03/2015/2015-08-03-C++学习笔记之三/","title":"C++学习笔记之三"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++学习笔记之三 | LOST HOME</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-S001LDMM2K"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-S001LDMM2K","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LOST HOME</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">YESTERDAY YOU SAID TOMORROW</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="nav-number">1.2.</span> <span class="nav-text">左值和右值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">求值顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">逻辑和关系运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">递增递减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">成员访问运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.</span> <span class="nav-text">条件运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">8.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">9.</span> <span class="nav-text">sizeof运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.1.</span> <span class="nav-text">算数转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.2.</span> <span class="nav-text">其他隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.3.</span> <span class="nav-text">显示转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static-cast"><span class="nav-number">10.3.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const-cast"><span class="nav-number">10.3.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">10.3.3.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">10.3.4.</span> <span class="nav-text">reinterpret_cast</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bill Lv</p>
  <div class="site-description" itemprop="description">YESTERDAY YOU SAID TOMORROW</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lber19535.github.io/2015/08/03/2015/2015-08-03-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bill Lv">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LOST HOME">
      <meta itemprop="description" content="YESTERDAY YOU SAID TOMORROW">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++学习笔记之三 | LOST HOME">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++学习笔记之三
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-08-03 17:00:00" itemprop="dateCreated datePublished" datetime="2015-08-03T17:00:00+00:00">2015-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-30 09:51:54" itemprop="dateModified" datetime="2022-08-30T09:51:54+00:00">2022-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="firestore-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>阅读 《C++Primer 第五版》第四章 表达式 所做的一些笔记。</p>
<span id="more"></span>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>一元运算符：作用于一个对象</li>
<li>二元运算符：作用于两个运算对象</li>
<li>其他：三元运算符和函数调用，其中三元运算符可以做用于三个运算对象，函数调用则对运算对象没有限制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三元运算符 ?:</span><br><span class="line"><span class="type">bool</span> b = x &gt; y ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>表达式运算的时候有优先级、结合律和运算顺序。</p>
<p>在表达式求职过程中运算对象常常被转换成不同类型，例如int转为float等，通常bool、char、short会被提升为int来做计算。</p>
<p>运算符重载可以用在复合类型的表达式中，像io的&lt;&lt;和&gt;&gt;，string的+等。</p>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>左值和右值原本是C中概念，左值位于赋值语句的左边，右值位于赋值语句的右边。然而在C++中意义就不一样了，归纳起来是：<strong>当一个对象被用作右值的时候，用的是对象的值（内容），当一个对象被用作左值的时候，用的是对象的身份（内存中的位置，即地址）</strong>。</p>
<h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>优先级规定了对象的组合方式但是没有说明求值顺序，有些运算符是没有规定求值顺序的，所以在使用的时候要避免表达式中出现歧义的顺序，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>由于&lt;&lt;没有定义的求值顺序，所以可能输出0，1也可能输出1，1。经过测试在vs2015和g++ 4.8中结果都是1，1。不过这种未定义的行为很可能不同编译器实现的时候做法不一样，所以不要这样写。</p>
<p>准则：</p>
<ul>
<li>关于优先级，其中括号的优先级最高，如果你不确定你写的表达式的运算顺序，最好还是加上括号。</li>
<li>如果表达式中改变了某个运算对象的值，那么这个表达式中的其他地方就不要再使用这个运算对象了<br>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ii = i++ + i++;  <span class="comment">// to bad</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>这部分粗略的看了下和java很像，这里写一些不一样的地方。</p>
<ul>
<li>C++中的bool值在运算的时候会被提升为int，然而bool值只有两个值，0或1，不是0的值都会被转成1。在Java中boolean值无法参加运算。</li>
<li>运算溢出，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">32767</span>;  <span class="comment">// 7FFF</span></span><br><span class="line">s += <span class="number">1</span>;           <span class="comment">// 8000 由于负数是补码表示的，这里符号位是负</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; <span class="comment">//  -32768</span></span><br></pre></td></tr></table></figure></li>
<li>整数相除结果还是整数，余数会被丢弃<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">21</span> / <span class="number">6</span>;  <span class="comment">// i是3</span></span><br></pre></td></tr></table></figure></li>
<li>取余的定义：(m &#x2F; n) * n + m % n &#x3D; m例如：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">21</span> % -<span class="number">8</span>:</span><br><span class="line">(-<span class="number">21</span> / -<span class="number">8</span>) * -<span class="number">8</span> + m % n = -<span class="number">21</span></span><br><span class="line">m % n = -<span class="number">21</span> + <span class="number">8</span> * (-<span class="number">21</span> / -<span class="number">8</span>);</span><br><span class="line">m % n = -<span class="number">21</span> + <span class="number">8</span> * <span class="number">2</span></span><br><span class="line">m % n = -<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="逻辑和关系运算"><a href="#逻辑和关系运算" class="headerlink" title="逻辑和关系运算"></a>逻辑和关系运算</h3><p>这部分和Java几乎一样，有些补充的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *cp = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(cp &amp;&amp; *cp)    <span class="comment">//这里cp中都是有内容的，所以都是true的</span></span><br><span class="line"><span class="comment">//如果是下面这样</span></span><br><span class="line"><span class="type">char</span> *cp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(cp)   <span class="comment">//这里是false，因为nullptr是0</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;  <span class="comment">// 这里是初始化而不是赋值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;         <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">1</span>;                   <span class="comment">// 这里是赋值</span></span><br><span class="line">k = &#123;<span class="number">1</span>&#125;;                 <span class="comment">// C++11 中加入的初始值列表</span></span><br></pre></td></tr></table></figure>
<p>对于类类型来说，初始化的细节取决于类本身的构造函数。<br>赋值运算的优先级是比较低的所以经常会有如下的戴妈：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>((i = get_value) != <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>C++允许赋值语句作为运算条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i = j)</span><br></pre></td></tr></table></figure>
<p>如果赋值后i的值非0，那么这里是true</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>这里也和Java中一样包括对i++和++i的使用还有何时使用等。</p>
<h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p>Java中的成员是用点来访问，C++中点用来访问类对象成员，箭头用于指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string *sp = &amp;s;</span><br><span class="line"><span class="keyword">auto</span> n1 = sp-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">auto</span> n2 = (*sp).<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">auto</span> n3 = s.<span class="built_in">size</span>();    <span class="comment">//三者等价</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string size is &quot;</span> &lt;&lt; n1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算的就是?:，可嵌套。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">cout &lt;&lt; ((i &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ((i &gt; <span class="number">0</span>) ? ((i &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>) : <span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>随着嵌套层数的增加可读性会下降，实际使用中应该注意嵌套层数。</p>
<p>习题4.21：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	*iter % <span class="number">2</span> ? *iter *= <span class="number">2</span> : <span class="literal">NULL</span>;</span><br><span class="line">	iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习题4.22：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> grade = <span class="number">74</span>;</span><br><span class="line"><span class="keyword">auto</span> result = grade &gt; <span class="number">90</span> ? <span class="string">&quot;high pass&quot;</span> : ((grade &gt; <span class="number">75</span>) ? <span class="string">&quot;low pass&quot;</span> : ((grade &gt; <span class="number">60</span>) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>));</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算中小整型（short，char， bool）会被自动提升为较大的整数类型，对象可以是带符号的也可以是无符号的。关于符号位如何处理，标准中并没有规定，书中推荐将位运算符用于无符号数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0223</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b1 = bits &lt;&lt; <span class="number">31</span>;</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b1).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// int</span></span><br></pre></td></tr></table></figure>
<p>从这里可以看出，在对待小整型的时候编译器对其进行了提升。另外，位移操作不会改变数据本身的值，而是对值位移后生成一个copy。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ii = ~i &lt;&lt; <span class="number">6</span>;   <span class="comment">//在~之前i被提升为int，由8位变成了32位，然后取反得到fffffffe，然后左移6位，得到ffffff80</span></span><br></pre></td></tr></table></figure>

<p>位运算符（&amp;，|）不要和逻辑运算符（&amp;&amp;，||）混淆了。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; endl;  <span class="comment">// &lt;&lt;是对位移运算符进行了重载</span></span><br></pre></td></tr></table></figure>

<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>szieof运算符返回一个表达式或者个一个类型所占的<strong>字节数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(type)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br><span class="line"><span class="comment">// 这是sizeof的两种形式，第一种用于返回类型的大小，第二种用于返回表达式结果类型的大小</span></span><br><span class="line">string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sizeof</span>(string)  <span class="comment">// string是类，所以有括号</span></span><br><span class="line"><span class="keyword">sizeof</span> s;       <span class="comment">// s是表达式，所以不需要括号</span></span><br><span class="line"><span class="comment">// 在使用中发现vs中可以写成 sizeof string而不需要加括号，但是g++中必须要加</span></span><br><span class="line"><span class="comment">// 总的来说加括号可以方便代码移植，也可以便于阅读</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *ip = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sizeof</span>(*p);  <span class="comment">// 指向对象的大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(p);   <span class="comment">// 指针大小固定为4</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sizeof</span>(s);</span><br><span class="line"><span class="built_in">sizeof</span>(string);  <span class="comment">// 这两个是等价的</span></span><br><span class="line">string *sp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">sizeof</span>(*sp);    <span class="comment">// 并不会因为指针是空而报错，他只会测量对应类型的大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(arr);   <span class="comment">// 整个数组的大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(*arr);  <span class="comment">// *arr是数组的第一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++中有着和Java相似的隐式转换，发生隐式转换条件：</p>
<ul>
<li>大多数表达式中比int小的会被提升为int</li>
<li>在条件中非bool类型会被转为bool类型</li>
<li>初始化过程中，初始值转换为变量类型；赋值语句中右侧对象1转成左侧对象的类型，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">3.14</span>;      <span class="comment">// i1 为3</span></span><br><span class="line"><span class="type">int</span> i2 = <span class="number">3.14</span> + i1;   <span class="comment">// 编译器会先将3.14转为3，然后和i1相加，i2为6</span></span><br></pre></td></tr></table></figure></li>
<li>如果算术运算或关系运算对象有多种类型，需要转换成同一种类型</li>
<li>函数调用也会发生类型转换（后面会讲这里就先不看了）</li>
</ul>
<h4 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h4><p>1.整型提升<br>2.无符号类型的运算对象</p>
<ul>
<li>首先进行整型提升</li>
<li>如果无符号类型的值<strong>大于</strong>有符号的，那么有符号的会转成无符号的</li>
<li>如果无符号类型的值<strong>小于</strong>有符号的，<strong>那么首先要看带符号类型能不能存下无符号的那个数，如果可以，则无符号变为有符号，如果不可以，则有符号的会转成无符号的</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> s2 = <span class="number">32768</span>;</span><br><span class="line">cout &lt;&lt; s1 + s2 &lt;&lt; endl; <span class="comment">//32769，变为整型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">4294967296</span> / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i2 = <span class="number">4294967296</span> / <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; i1 + i2 &lt;&lt; endl;   <span class="comment">// 由于i2大于i1所以i1被提升为无符号的数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h4><p>除了基础类型的转换外还包括一些其他类型的转换：</p>
<ul>
<li><p>数组转换成指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = ia;   <span class="comment">// 这时候数组转换成了数组指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针的转换（nullptr可以转换成任意指针，任意非常量指针可以转成void *）</p>
</li>
<li><p>指针转bool</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *cp = <span class="built_in">get_string</span>();</span><br><span class="line"><span class="keyword">if</span>(cp)  <span class="comment">// 如果指针不是0，则为真</span></span><br><span class="line"><span class="keyword">if</span>(*cp) <span class="comment">//如果不是空字符串，则为真</span></span><br></pre></td></tr></table></figure></li>
<li><p>非常量可以转为常量的指针或者引用，但是反过来不行。</p>
</li>
</ul>
<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>显示转换包括static_cast，dynamic_cast，const_cast。</p>
<h5 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line"><span class="type">void</span> *vp = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span> *&gt;(vp);</span><br></pre></td></tr></table></figure>
<p>static_cast的一个好处就是可以把编译器做不到的指针的类型转换做到，正如上面的一个void *到double *的过程。使用的的时候一定要在确定这样转到的类型是对的才可以用，否则会引发未定义的错误。</p>
<h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>用于去掉const的限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> *cp2 = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(cp1);  <span class="comment">//对比直接赋值，这样拿到的指针就不是const的了</span></span><br><span class="line"><span class="type">char</span> *cp3 = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">cp2 = cp3;</span><br></pre></td></tr></table></figure>
<h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p>和static_casr转换结果类似，不同的是在遇到不安全的downcast的时候会返回一个nullptr指针。书后面才讲这里就不详细查了。</p>
<h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p>这个强制类型转换并不像前面两个会对变量的值进行重新解释，而只是单纯的把二进制复制到所要转换的类型的内存中，当在使用的时候很可能因为不同类型对于这一块二进制的解释不同导致运行是错误</p>
<p><strong>出了函数重载的时候可以使用const_cast之外，其他时间使用强制类型转换很大程度上说明程序设计上的问题。实际开发中应该尽量避免强制类型转换。</strong></p>
<p>除此之外还有旧的强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="built_in">double</span>(i); <span class="comment">// C++ style</span></span><br><span class="line">doubel d2 = (doubel)i; <span class="comment">// C style</span></span><br></pre></td></tr></table></figure>
<p>这种转换会根据涉及到的类型做出和上面那些强制类型转换相同的行为，但是这种写法不能很清晰的反应转换的种类，易读和调试起来都不方便，所以不推荐使用。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2015/07/16/2015/2015-07-16-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C/" rel="prev" title="C++学习笔记之二">
                  <i class="fa fa-chevron-left"></i> C++学习笔记之二
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2015/08/10/2015/2015-08-10-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B/" rel="next" title="C++学习笔记之四">
                  C++学习笔记之四 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bill Lv</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.9.1/firebase-app-compat.js" integrity="sha256-BZqADJTynzztcubgFmplXDkhMk7o/6KO4tHzL8X+biE=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.9.1/firebase-firestore-compat.js" integrity="sha256-8Y5+rcygX0v5tCQhOjr4rob7oykEcp6IhhutNKKGzfk=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="firestore" type="application/json">{"enable":true,"collection":"articles","apiKey":"AIzaSyAUEkp4sjguJNc-EW2Hu8T3WQ57z931SbA","projectId":"blog-7bba0"}</script>
  <script src="/js/third-party/statistics/firestore.js"></script>




</body>
</html>
